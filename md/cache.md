# 静态资源加载和更新的策略

## 前言
对于页面中的静态资源，包括html,css.js,font等，理想来说:
1. 页面以最快的速度获取静态资源
2. 服务器上静态资源没有更新的时候再次访问不会请求服务器
3. 服务器上静态资源更新的时候页面再次以最快的速度获取静态资源

当然除了速度，缓存还有别的功效，比如 <b>减少带宽请求，减少服务器压力，减少网络延迟，加快页面打开速度</b>

## 缓存策略

缓存策略大致可以这么分为几个方面: 
* 浏览器缓存
  * HTTP缓存机制
    * 协商缓存阶段
      * Last-Modified&if-modified-since
      * ETag&If-None-Match
    * 本地缓存阶段
      * Cache-Control
      * Expires
* 服务器缓存
  * CDN缓存
  * Combo服务
* HTML5缓存思路
  * 离线存储manifest
  * 本地存储LocalStorage


## 浏览器缓存

> 对于浏览器来说，缓存规则是在<i>HTTP协议头</i>和<i>HTML页面的meta标签</i>定义的，通过<b>过期机制</b>和<b>验证机制</b>来判断浏览器是直接拿缓存还是去服务器获取新的资源。

过期机制: 也就是缓存的有效期(含有HTTP协议报头并且在有效期内而且使用过缓存)  
验证机制: 服务器返回资源的时候会在控制头信息上添加一个ETag，检查是否匹配，若不匹配，则说明资源已经过期或者已经被修改过了，浏览器需要重新获取静态资源。  


## HTTP缓存机制

### 协商缓存阶段

> 如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源。

详情可以看[这篇文章](https://github.com/angelasubi/blog/blob/master/md/http304.md)

### 本地缓存阶段

> 就是在本地找这个资源，如果这个资源存在并且没有过期，那么就直接用这个资源。

#### Expires
在浏览器上存储距过期还有多少时间，等同Cache-control中的max-age的效果，如果同时存在，则被Cache-Control的max-age覆盖。若把其值设置为0，则表示页面立即过期。并且若此属性在页面当中被设置了多次，则取其最小值。

#### Cache-Control
HTTP/1.0 没有实现 Cache-Control，所以为了兼容 HTTP/1.0 出现了Pragma字段

* public: 需要http身份验证，响应不可以缓存，只有加上public才可以被缓存，并且在多用户之间共享。
* private: 默认值，响应可以作为私有的缓存，不能在用户之间共享。
* no-cache: 强制浏览器在使用cache的时候先发送一个请求给服务器进行确认。
* max-age: 指定缓存过期的<b>相对</b>时间秒数，max-ag=0或者是负值，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00

## 服务端缓存

### CDN缓存

浏览器开始向CDN网关发起WEB请求，网关服务器后面对应的一台或者多台负载均衡源服务器，会根据负载请求，动态请求转发到合适的源服务器上。

#### CDN缓存策略

CDN边缘节点缓存策略因服务商不同而不同，但会遵循http标准协议，通过http响应头中的Cache-Control:max-age的字段来设置CDN边缘节点数据缓存事件。  

当用户向CDN节点请求数据时，CDN会判断缓存数据是否过期，如果缓存数据没有过期，则直接将缓存数据返回给客户端；反之，CDN节点就会向源站发出回源请求，从源站拉去最新数据，更新本地缓存，并将最新数据返回给客户端。  

CDN服务器商一般会提供基于文件后缀、目录多个纬度来指定CDN缓存事件，为用户提供更精细化的缓存管理。  

CDN缓存时间会对<i>"回源率"</i>产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大了访问延迟；若CDN缓存时间太长，会带来数据更新慢的问题。所以要根据特定的业务，作出特定的数据缓存的时间管理。


#### Combo服务

简单来说，就是根据ur找到对应的多个文件，合并成一个文件来响应请求，缓存，<b>从而减少HTTP请求的需求</b>，以加快访问速度。


## HTML5缓存思路

### manifest

* 可以直接访问本地的缓存文件
* 离线可以访问
* 仅加载被修改的资源

```js
CACHE MANIFEST

# 缓存入口
CACHE:

# 在线访问
NETWORK:

# 比如404 ？
FALLBACK:
```

1. 如果服务器对离线资源进行了更新，那么必须更新manifest。如果没有更新manifest文件的话，就算更新了资源还是没用，依旧使用的是原来离线存储的资源。  
2. 如果对manifest进行了更新，但是本地缓存的manifest还没过期，这样还是用本地的manifest，所以不要对manifest设置缓存。
3. 由于浏览器在下载manifest的时候，会一次性全部下载所有的资源，如果下载失败了，就算更新失败，还是用原来的资源。
4. 如果更新了资源，那么要重新打开才会生效，如果要立刻马上生效，就要用到 <i>window.applicationCache.swapCache()</i>

### LocalStorage

主要就是 setItem, removeItem, getItem 的使用。 如果不主动去删除，它永远都是在本地的。

## 最后

### 缓存站点的一些建议

* 为图像、CSS和共享的内容建立特定的文件夹
* 使用同样的URL来表示同样的内容
* 尽可能使用CSS图像拼接
* 尽可能将主机脚本和外部资源本地化
* 对缓存内容收集文件摘要
* 减少对Cookie的依赖
* 减少对HTTPS加密协议的使用


### 扩展阅读
- 来自MDN的[HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)