# 浅谈算法的时间复杂度和空间复杂度

一般来说，在写算法之前，我们都需要两项分析。
1. 从数学上证明算法的正确性
2. 分析算法的时间复杂度

算法的执行时间需要通过依据算法编织的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。

## 一、事后统计的方法
在事后统计算法的执行时间是可行的，但是这个方法有有两个不好的地方:
1. 对设计的算法的运行性能进行评测，必须根据算法编制相应的程序并实际实现
2. 所得时间的统计量依赖于计算机的硬件、软件等环境因素，使人无法发现算法本身的优势


## 二、事前分析估算法

因事后统计法更多依赖于计算机的硬件、软件等因素，很多时候容易掩盖掉算法本身的优劣。所以通常采用事前分析估算的方法。  

一个程序在计算机上运行时所消耗的时间取决于下列几个因素：
1. 算法采用的策略，方法
2. 编译产生的代码质量
3. 问题的输入规模
4. 机器执行指令的速度
一个算法是由控制结构（顺序、分支和循环3种）和原操作（固定数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常是从算法中选取一种对于所研究的问题或者算法类型来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。


### 时间复杂度
1. 时间频度 
一个算法执行所消耗的时间必须运行测试才能知道。但是不可能没个算法都去测试，所以只要知道哪个算法花费的时间多和少久可以了。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法执行的语句多，那么花费的时间就多。一个算法中的语句执行次数称为语句频度或时间频道，计为T(n)。
2. 时间复杂度 
在时间频度中，n称为问题的规模，当n不断变化的时候，时间频度T(n)也会不断的变化。如果想知道变化的时候呈现出来是什么规律，所以就引入时间复杂度概念。一般情况夏，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n) = O(f(n))，O(f(n))为算法的渐进时间复杂度，简称时间复杂度。
T(n) = O(f(n))表示存在一个常数C，使得在当n趋于正无穷时总由T(n) ≤ C * f(n)。简单来说，就是T(n)在n趋紧于正无穷时最大也和f(n)差不多。也就是说当n趋于正无穷时T(n)的上界是C * f(n)。